globalVariable(name) ::= "<name> = global i8* null, align 8"
localVariable(name) ::= <<
<name> = alloca i8*, align 8
store i8* null, i8** <name>, align 8
>>

functionCall(name) ::= "call void @<name>()"
function(name, code) ::= <<
define void @<name>() #3 {
  <code :{ line | <line><\n>}>
}


>>

functionReturn() ::= "ret void"

unwrap() ::= "call void @_Z7_unwrapv()"

conditionalStart(index) ::= <<
  %.conditional_<index>_start_var1 = call zeroext i1 @_Z6toBoolv()
  %.conditional_<index>_start_var2 = icmp eq i1 %.conditional_<index>_start_var1, 0
  br i1 %.conditional_<index>_start_var2, label %.conditional_<index>_label_false, label %.conditional_<index>_label_true
  .conditional_<index>_label_true:
>>
conditionalEnd(index) ::= <<
  br label %.conditional_<index>_label_false
  .conditional_<index>_label_false:
>>

loopConditional(index) ::= <<
  %.loopConditional_<index>_start_var1 = call zeroext i1 @_Z6toBoolv()
  %.loopConditional_<index>_start_var2 = icmp eq i1 %.loopConditional_<index>_start_var1, 0
  br i1 %.loopConditional_<index>_start_var2, label %.loopConditional_<index>_label_false, label %.loopConditional_<index>_label_true
  .loopConditional_<index>_label_true:
>>
loopConditionalEnd(index) ::= <<
  br label %.loopConditional_<index>_label_false
  .loopConditional_<index>_label_false:
>>

loopStart(index) ::= <<
  br label %.loop_<index>_label
  .loop_<index>_label:
>>

loopEnd(index) ::= <<
  br label %.loop_<index>_label
  .break_<index>_label:
>>

continueStatement(index) ::= <<
  br label %.loop_<index>_label
>>

breakStatement(index) ::= <<
 br label %.break_<index>_label
>>

// name is the unique name of the tuple
// fields are the data types in llvm form (e.g. i32, i8, etc.)
tuple_struct(name, fields) ::= <<
%Gaz_Struct.<name> = type {<fields; separator=",\n">}
>>
varInit_tuple(tuple_statements) ::= <<
call void @_Z14pushEmptyTuplev();
<tuple_statements; separator="\n">
>>
pushNullIntegerToTuple(value) ::= <<
call void @_Z18pushIntNullToTuplev()
>>
pushNullRealToTuple(value) ::= <<
call void @_Z19pushRealNullToTuplev()
>>
pushNullBooleanToTuple(value) ::= <<
call void @_Z19pushBoolNullToTuplev()
>>
pushNullCharacterToTuple(value) ::= <<
call void @_Z19pushCharNullToTuplev()
>>
// expects the expression is already in stack
assignTupleField(index) ::= <<
call void @_Z8setTuplei(i32 <index>)
>>

// TODO: NOTE MAY HAVE TO MAKE TUPLE FIELD ASSIGN BY VAR
assignTupleField2(index) ::= <<
call void @_Z16assignTupleFieldv()
>>

getTupleField(index) ::= <<
call void @_Z15getValueAtTuplei(i32 <index>)
>>

pushVariable(name) ::= <<
; push variable
call void @_Z4pushPPv(i8** <name>)
>>
pushVariableValue(name) ::= <<
; push variable value
call void @_Z17pushVariableValuePPv(i8** <name>)
>>
assignVariable(name) ::= <<
; assign byref
call void @_Z6assignPPv(i8** <name>)
>>
assignByVar(name) ::= <<
; assign byvar
call void @_Z10assignCopyPPv(i8** <name>)
>>

varInit_integer() ::= "call void @_Z22varInitPushNullIntegerv()"
varInit_output() ::= "call void @_Z10std_outputv()"
varInit_input() ::= "call void @_Z9std_inputv()"
varInit_boolean() ::= "call void @_Z22varInitPushNullBooleanv()"
varInit_real() ::= "call void @_Z19varInitPushNullRealv()"
varInit_character() ::= "call void @_Z24varInitPushNullCharacterv()"

swapStack() ::= "call void @_Z15swapStackTopTwov()"

promoteTo(typeLetter) ::= "call void @_Z11promoteTo_<typeLetter>()"
promoteToVector() ::= "call void @_Z16promoteTo_vectorv()"

pushNull() ::= "call void @_Z8pushNullv()"
pushIdentity() ::= "call void @_Z12pushIdentityv()"
pushInteger(value) ::= "call void @_Z11pushIntegeri(i32 <value>)"
pushBoolean(value) ::= "call void @_Z11pushBooleanb(i1 zeroext <value>)"
pushReal(value) ::= "call void @_Z8pushRealf(float <value>)"
pushCharacter(value) ::= "call void @_Z13pushCharacterc(i8 signext <value>)"

startVector() ::= <<
; starting of a vector
call void @_Z15pushStartVectorv()
>>
endTuple() ::= <<
call void @_Z8endTuplev()
; ending of a vector
>>
endInterval() ::= "call void @_Z11endIntervalv()"

getAt(index) ::= "call void @_Z5getAti(i32 <index>)"
getAt2() ::= "call void @_Z6getAt2v()"
setAt(index) ::= "call void @_Z8setTuplei(i32 <index>)"

addition(typeLetter) ::= "call void @_Z5add_<typeLetter>()"
subtraction(typeLetter) ::= "call void @_Z5sub_<typeLetter>()"
multiplication(typeLetter) ::= "call void @_Z5mul_<typeLetter>()"
division(typeLetter) ::= "call void @_Z5div_<typeLetter>()"
modulus(typeLetter) ::= "call void @_Z5mod_<typeLetter>()"
exponentiation(typeLetter) ::= "call void @_Z5exp_<typeLetter>()"
negation(typeLetter) ::= "call void @_Z5neg_<typeLetter>()"
lessthan(typeLetter) ::= "call void @_Z5lt__<typeLetter>()"
greaterthan(typeLetter) ::= "call void @_Z5gt__<typeLetter>()"
lessthanequal(typeLetter) ::= "call void @_Z5leq_<typeLetter>()"
greaterthanequal(typeLetter) ::= "call void @_Z5geq_<typeLetter>()"
equal(typeLetter) ::= "call void @_Z5eq__<typeLetter>()"
notequal(typeLetter) ::= "call void @_Z5neq_<typeLetter>()"
logicalor(typeLetter) ::= "call void @_Z5lor_<typeLetter>()"
logicalxor(typeLetter) ::= "call void @_Z5lxr_<typeLetter>()"
logicaland(typeLetter) ::= "call void @_Z5lnd_<typeLetter>()"

addInterval() ::= "call void @_Z12add_Intervalv()"
subInterval() ::= "call void @_Z12sub_Intervalv()"
multInterval() ::= "call void @_Z13mult_Intervalv()"
divInterval() ::= "call void @_Z12div_Intervalv()"
negInterval() ::= "call void @_Z12neg_Intervalv()"
equalInterval() ::= "call void @_Z11eq_Intervalv()"
notequalInterval() ::= "call void @_Z12neq_Intervalv()"
byInterval(value) ::= "call void @_Z10byIntervali(i32 <value>)"

notEqualNull() ::="call void @_Z8neq_nullv()"

shrinkIterateVector() ::="call void @_Z19shrinkIterateVectorv()"

rightArrowOperator() ::= "call void @_Z18rightArrowOperatorv()"
leftArrowOperator() ::= "call void @_Z17leftArrowOperatorv()"

noop() ::= <<
    call void @_Z4noopv()
>>